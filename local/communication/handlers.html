<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Handlers - The Kompact Book</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide, Manual, and Tutorial for the Kompact actor-component-hybrid systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="../../getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="../../introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../introduction/components.html"><strong aria-hidden="true">1.1.</strong> Components</a></li><li class="chapter-item expanded "><a href="../../introduction/actors.html"><strong aria-hidden="true">1.2.</strong> Actors</a></li><li class="chapter-item expanded "><a href="../../introduction/state.html"><strong aria-hidden="true">1.3.</strong> Internal State</a></li></ol></li><li class="chapter-item expanded "><a href="../../local/index.html"><strong aria-hidden="true">2.</strong> Local Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../local/communication/index.html"><strong aria-hidden="true">2.1.</strong> Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../local/communication/messagesandevents.html"><strong aria-hidden="true">2.1.1.</strong> Messages and Events</a></li><li class="chapter-item expanded "><a href="../../local/communication/state.html"><strong aria-hidden="true">2.1.2.</strong> State</a></li><li class="chapter-item expanded "><a href="../../local/communication/handlers.html" class="active"><strong aria-hidden="true">2.1.3.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="../../local/communication/ask.html"><strong aria-hidden="true">2.1.4.</strong> Ask</a></li><li class="chapter-item expanded "><a href="../../local/communication/system.html"><strong aria-hidden="true">2.1.5.</strong> System</a></li><li class="chapter-item expanded "><a href="../../local/communication/senders.html"><strong aria-hidden="true">2.1.6.</strong> Senders</a></li></ol></li><li class="chapter-item expanded "><a href="../../local/timers.html"><strong aria-hidden="true">2.2.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../../local/schedulers.html"><strong aria-hidden="true">2.3.</strong> Schedulers</a></li><li class="chapter-item expanded "><a href="../../local/logging.html"><strong aria-hidden="true">2.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="../../local/configuration.html"><strong aria-hidden="true">2.5.</strong> Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="../../distributed/index.html"><strong aria-hidden="true">3.</strong> Distributed Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../distributed/basiccommunication.html"><strong aria-hidden="true">3.1.</strong> Basic Communication</a></li><li class="chapter-item expanded "><a href="../../distributed/namedservices.html"><strong aria-hidden="true">3.2.</strong> Named Services</a></li><li class="chapter-item expanded "><a href="../../distributed/serialisation.html"><strong aria-hidden="true">3.3.</strong> Serialisation</a></li><li class="chapter-item expanded "><a href="../../distributed/networkbuffers.html"><strong aria-hidden="true">3.4.</strong> Configuring Buffers</a></li></ol></li><li class="chapter-item expanded "><a href="../../async/index.html"><strong aria-hidden="true">4.</strong> Async/Await Interaction</a></li><li class="chapter-item expanded affix "><a href="../../project.html">Project Info</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Kompact Book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/kompics/kompact" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#handlers" id="handlers">Handlers</a></h1>
<p>Now that we have set up all the messages, events, and the state, we need to actually implement the behaviours of the <code>Manager</code> and the <code>Worker</code>. That means we need to implement the <code>Actor</code> trait for both components, to handle the messages we are sending, and we also need to implement the appropriate event handling traits: <code>ComponentLifecycle</code> and <code>Require&lt;WorkerPort&gt;</code> for the <code>Manager</code>, and <code>Provide&lt;ControlPort&gt;</code> and <code>Provide&lt;WorkerPort&gt;</code> for the <code>Worker</code>.</p>
<h2><a class="header" href="#worker" id="worker">Worker</a></h2>
<h3><a class="header" href="#actor" id="actor">Actor</a></h3>
<p>Since the worker is stateless, its implementation is really simple. It’s basically just a francy wrapper around a slice <code>fold</code>. That is, whenever we get a <code>WorkPart</code> message on our <code>receive_local(...)</code> function from the <code>Actor</code> trait, we simply take a slice of the range we were allocated to work on, and then call <code>fold(msg.neutral, msg.merger)</code> on it to produce the desired <code>u64</code> result. And then we simply wrap the result into a <code>WorkResult</code>, which we trigger on our instance of <code>WorkerPort</code> so it gets back to the manager.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span>impl Actor for Worker {
    type Message = WorkPart;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        let my_slice = &amp;msg.data[msg.range];
        let res = my_slice.iter().fold(msg.neutral, msg.merger);
        self.worker_port.trigger(WorkResult(res));
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(Ask::of(work)).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h3><a class="header" href="#ports" id="ports">Ports</a></h3>
<p>We also need to provide implementations for <code>ComponentLifecycle</code> and <code>WorkerPort</code>, because they are expected by Kompact. However, we don’t actually want to do anything interesting with them. So we are going to use the <code>ignore_lifecycle!(Worker)</code> macro to generate an empty <code>ComponentLifecycle</code> implementation, and similarly use the <code>ignore_requests!(WorkerPort, Worker)</code> macro to generate an empty <code>Provide&lt;WorkerPort&gt;</code> implementation.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>ignore_lifecycle!(Worker);
ignore_requests!(WorkerPort, Worker);
<span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(Ask::of(work)).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#manager" id="manager">Manager</a></h2>
<p>The manager needs to do three things: 1) Manage the worker pool, 2) split up work requests and send chunks to workers, and 3) collect the results from the workers, combine them, and reply with the final result.</p>
<p>We will deal with 1) in a <code>ComponentLifecycle</code> handler, and with 3) in the handler for <code>WorkerPort</code>, of course. For 2), however, we want to use the “ask”-pattern again, so we will look at that in the next section.</p>
<h3><a class="header" href="#componentlifecycle" id="componentlifecycle">ComponentLifecycle</a></h3>
<p>Whenever the manager is started (or restarted after being paused) we must populate our pool of workers and connect them appropriately. We can create new components from within an actor by using the <code>system()</code> reference from the <code>ComponentContext</code>. Of course, we must also remember to actually start the new components, or nothing will happen when we send messages to them later. Additionally, we must fill the appropriate state with component instances and actor references, as we discussed in the previous section.</p>
<blockquote>
<p><strong>Note:</strong> As opposed to many other Actor or Component frameworks, Kompact does <strong>not</strong> produce a hierarchical structure when calling <code>create(...)</code> from within a component. This is because Kompact doesn’t have such a strong focus on error handling and supervision as other systems, and maintaining a hierarchical structure is more complicated than maintaining a flat one.</p>
</blockquote>
<p>When the manager gets shut down or paused we will clean up the worker pool completely. Even if we are only temporarily paused, it is better to reduce our footprint by cleaning up, than forgetting to do so and hanging on to all the pool memory while not running anyway.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for Manager {
    fn on_start(&amp;mut self) -&gt; Handled {
        // set up our workers
        for _i in 0..self.num_workers {
            let worker = self.ctx.system().create(Worker::new);
            worker.connect_to_required(self.worker_port.share());
            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
            self.ctx.system().start(&amp;worker);
            self.workers.push(worker);
            self.worker_refs.push(worker_ref);
        }
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        // clean up after ourselves
        self.worker_refs.clear();
        let system = self.ctx.system();
        self.workers.drain(..).for_each(|worker| {
            system.stop(&amp;worker);
        });
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">impl Require&lt;WorkerPort&gt; for Manager {
</span><span class="boring">    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
</span><span class="boring">        if self.outstanding_request.is_some() {
</span><span class="boring">            self.result_accumulator.push(event.0);
</span><span class="boring">            if self.result_accumulator.len() == (self.num_workers + 1) {
</span><span class="boring">                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
</span><span class="boring">                let work: &amp;Work = ask.request();
</span><span class="boring">                let res = self
</span><span class="boring">                    .result_accumulator
</span><span class="boring">                    .iter()
</span><span class="boring">                    .fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.clear();
</span><span class="boring">                let reply = WorkResult(res);
</span><span class="boring">                ask.reply(reply).expect(&quot;reply&quot;);
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            error!(
</span><span class="boring">                self.log(),
</span><span class="boring">                &quot;Got a response without an outstanding promise: {:?}&quot;, event
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(Ask::of(work)).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> We are getting the required <code>ActorRefStrong&lt;WorkPart&gt;</code> by first calling <code>actor_ref()</code> on a worker instance and then upgrading the result via <code>hold()</code> from an <code>ActorRef&lt;WorkPart&gt;</code> to <code>ActorRefStrong&lt;WorkPart&gt;</code>. This returns a <code>Result</code>, as upgrading is impossible if the component is already deallocated. However, since we are holding on to the actual instance of the component here as well, we <em>know</em> it’s not deallocated, yet, and <code>hold()</code> cannot fail, so we simply call <code>expect(...)</code> to unwrap it.</p>
</blockquote>
<h3><a class="header" href="#worker-port" id="worker-port">Worker Port</a></h3>
<p>Whenever we get a <code>WorkResult</code> from a worker, we will temporarily store it in <code>self.result_accumulator</code>, as long we have an outstanding request. After every new addition to the accumulator, we check if we have gotten all responses with <code>self.result_accumulator.len() == (self.num_workers + 1)</code> (again, more on the <code>+ 1</code> later). If that is so, we will do the final aggregation on the accumulator via <code>fold(work.neutral, work.merger)</code> and then <code>reply(...)</code> to the outstanding request. Of course, we must also clean up after ourselves, i.e. reset the <code>self.outstanding_request</code> to <code>None</code> and clear out <code>self.result_accumulator</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::{env, fmt, ops::Range, sync::Arc};
</span><span class="boring">
</span><span class="boring">struct Work {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl Work {
</span><span class="boring">    fn with(data: Vec&lt;u64&gt;, merger: fn(u64, &amp;u64) -&gt; u64, neutral: u64) -&gt; Self {
</span><span class="boring">        let moved_data: Arc&lt;[u64]&gt; = data.into_boxed_slice().into();
</span><span class="boring">        Work {
</span><span class="boring">            data: moved_data,
</span><span class="boring">            merger,
</span><span class="boring">            neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for Work {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;Work{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct WorkPart {
</span><span class="boring">    data: Arc&lt;[u64]&gt;,
</span><span class="boring">    range: Range&lt;usize&gt;,
</span><span class="boring">    merger: fn(u64, &amp;u64) -&gt; u64,
</span><span class="boring">    neutral: u64,
</span><span class="boring">}
</span><span class="boring">impl WorkPart {
</span><span class="boring">    fn from(work: &amp;Work, range: Range&lt;usize&gt;) -&gt; Self {
</span><span class="boring">        WorkPart {
</span><span class="boring">            data: work.data.clone(),
</span><span class="boring">            range,
</span><span class="boring">            merger: work.merger,
</span><span class="boring">            neutral: work.neutral,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl fmt::Debug for WorkPart {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;WorkPart{{
</span><span class="boring">            data=&lt;data of length={}&gt;,
</span><span class="boring">            range={:?},
</span><span class="boring">            merger=&lt;function&gt;,
</span><span class="boring">            neutral={}
</span><span class="boring">        }}&quot;,
</span><span class="boring">            self.data.len(),
</span><span class="boring">            self.range,
</span><span class="boring">            self.neutral
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct WorkResult(u64);
</span><span class="boring">struct WorkerPort;
</span><span class="boring">impl Port for WorkerPort {
</span><span class="boring">    type Indication = WorkResult;
</span><span class="boring">    type Request = Never;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Manager {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: RequiredPort&lt;WorkerPort&gt;,
</span><span class="boring">    num_workers: usize,
</span><span class="boring">    workers: Vec&lt;Arc&lt;Component&lt;Worker&gt;&gt;&gt;,
</span><span class="boring">    worker_refs: Vec&lt;ActorRefStrong&lt;WorkPart&gt;&gt;,
</span><span class="boring">    outstanding_request: Option&lt;Ask&lt;Work, WorkResult&gt;&gt;,
</span><span class="boring">    result_accumulator: Vec&lt;u64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Manager {
</span><span class="boring">    fn new(num_workers: usize) -&gt; Self {
</span><span class="boring">        Manager {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: RequiredPort::uninitialised(),
</span><span class="boring">            num_workers,
</span><span class="boring">            workers: Vec::with_capacity(num_workers),
</span><span class="boring">            worker_refs: Vec::with_capacity(num_workers),
</span><span class="boring">            outstanding_request: None,
</span><span class="boring">            result_accumulator: Vec::with_capacity(num_workers + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for Manager {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // set up our workers
</span><span class="boring">        for _i in 0..self.num_workers {
</span><span class="boring">            let worker = self.ctx.system().create(Worker::new);
</span><span class="boring">            worker.connect_to_required(self.worker_port.share());
</span><span class="boring">            let worker_ref = worker.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">            self.ctx.system().start(&amp;worker);
</span><span class="boring">            self.workers.push(worker);
</span><span class="boring">            self.worker_refs.push(worker_ref);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        // clean up after ourselves
</span><span class="boring">        self.worker_refs.clear();
</span><span class="boring">        let system = self.ctx.system();
</span><span class="boring">        self.workers.drain(..).for_each(|worker| {
</span><span class="boring">            system.stop(&amp;worker);
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span>impl Require&lt;WorkerPort&gt; for Manager {
    fn handle(&amp;mut self, event: WorkResult) -&gt; Handled {
        if self.outstanding_request.is_some() {
            self.result_accumulator.push(event.0);
            if self.result_accumulator.len() == (self.num_workers + 1) {
                let ask = self.outstanding_request.take().expect(&quot;ask&quot;);
                let work: &amp;Work = ask.request();
                let res = self
                    .result_accumulator
                    .iter()
                    .fold(work.neutral, work.merger);
                self.result_accumulator.clear();
                let reply = WorkResult(res);
                ask.reply(reply).expect(&quot;reply&quot;);
            }
        } else {
            error!(
                self.log(),
                &quot;Got a response without an outstanding promise: {:?}&quot;, event
            );
        }
        Handled::Ok
    }
}
<span class="boring">impl Actor for Manager {
</span><span class="boring">    type Message = Ask&lt;Work, WorkResult&gt;;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        assert!(
</span><span class="boring">            self.outstanding_request.is_none(),
</span><span class="boring">            &quot;One request at a time, please!&quot;
</span><span class="boring">        );
</span><span class="boring">        let work: &amp;Work = msg.request();
</span><span class="boring">        if self.num_workers == 0 {
</span><span class="boring">            // manager gotta work itself -&gt; very unhappy manager
</span><span class="boring">            let res = work.data.iter().fold(work.neutral, work.merger);
</span><span class="boring">            msg.reply(WorkResult(res)).expect(&quot;reply&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let len = work.data.len();
</span><span class="boring">            let stride = len / self.num_workers;
</span><span class="boring">            let mut start = 0usize;
</span><span class="boring">            let mut index = 0;
</span><span class="boring">            while start &lt; len &amp;&amp; index &lt; self.num_workers {
</span><span class="boring">                let end = len.min(start + stride);
</span><span class="boring">                let range = start..end;
</span><span class="boring">                info!(self.log(), &quot;Assigning {:?} to worker #{}&quot;, range, index);
</span><span class="boring">                let msg = WorkPart::from(work, range);
</span><span class="boring">                let worker = &amp;self.worker_refs[index];
</span><span class="boring">                worker.tell(msg);
</span><span class="boring">                start += stride;
</span><span class="boring">                index += 1;
</span><span class="boring">            }
</span><span class="boring">            if start &lt; len {
</span><span class="boring">                // manager just does the rest itself
</span><span class="boring">                let res = work.data[start..len].iter().fold(work.neutral, work.merger);
</span><span class="boring">                self.result_accumulator.push(res);
</span><span class="boring">            } else {
</span><span class="boring">                // just put a neutral element in there, so our count is right in the end
</span><span class="boring">                self.result_accumulator.push(work.neutral);
</span><span class="boring">            }
</span><span class="boring">            self.outstanding_request = Some(msg);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition)]
</span><span class="boring">struct Worker {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    worker_port: ProvidedPort&lt;WorkerPort&gt;,
</span><span class="boring">}
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Worker {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            worker_port: ProvidedPort::uninitialised(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore_lifecycle!(Worker);
</span><span class="boring">ignore_requests!(WorkerPort, Worker);
</span><span class="boring">
</span><span class="boring">impl Actor for Worker {
</span><span class="boring">    type Message = WorkPart;
</span><span class="boring">
</span><span class="boring">    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
</span><span class="boring">        let my_slice = &amp;msg.data[msg.range];
</span><span class="boring">        let res = my_slice.iter().fold(msg.neutral, msg.merger);
</span><span class="boring">        self.worker_port.trigger(WorkResult(res));
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn receive_network(&amp;mut self, _msg: NetMessage) -&gt; Handled {
</span><span class="boring">        unimplemented!(&quot;Still ignoring networking stuff.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">    assert_eq!(
</span><span class="boring">        3,
</span><span class="boring">        args.len(),
</span><span class="boring">        &quot;Invalid arguments! Must give number of workers and size of the data array.&quot;
</span><span class="boring">    );
</span><span class="boring">    let num_workers: usize = args[1].parse().expect(&quot;number&quot;);
</span><span class="boring">    let data_size: usize = args[2].parse().expect(&quot;number&quot;);
</span><span class="boring">    run_task(num_workers, data_size);
</span><span class="boring">}
</span><span class="boring">fn run_task(num_workers: usize, data_size: usize) {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let manager = system.create(move || Manager::new(num_workers));
</span><span class="boring">    system.start(&amp;manager);
</span><span class="boring">    let manager_ref = manager.actor_ref().hold().expect(&quot;live&quot;);
</span><span class="boring">
</span><span class="boring">    let data: Vec&lt;u64&gt; = (1..=data_size).map(|v| v as u64).collect();
</span><span class="boring">    let work = Work::with(data, overflowing_sum, 0u64);
</span><span class="boring">    println!(&quot;Sending request...&quot;);
</span><span class="boring">    let res = manager_ref.ask(Ask::of(work)).wait();
</span><span class="boring">    println!(&quot;*******\nGot result: {}\n*******&quot;, res.0);
</span><span class="boring">    assert_eq!(triangular_number(data_size as u64), res.0);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn triangular_number(n: u64) -&gt; u64 {
</span><span class="boring">    (n * (n + 1u64)) / 2u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn overflowing_sum(lhs: u64, rhs: &amp;u64) -&gt; u64 {
</span><span class="boring">    lhs.overflowing_add(*rhs).0
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_workers() {
</span><span class="boring">        run_task(3, 1000);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../local/communication/state.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../local/communication/ask.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../local/communication/state.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../local/communication/ask.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
